[{"content":"Cần biết trước  Nguyên lí bao hàm loại trừ Bài toán Chia kẹo Euler  Đề bài Tham khảo  HackerRank - K-Inversion Permutations Codeforces - [Tutorial] Inclusion-Exclusion Principle  Tóm tắt Cho hai số nguyên $n, k$. Đếm số lượng hoán vị của dãy ${1, 2, \\dots, n}$ có $k$ cặp nghịch thế.\n Subtask 1: $1 \\leq n \\leq 3000, 0 \\leq k \\leq \\min(C^2_n, 3000)$ Subtask 2: $1 \\leq n \\leq 10^5, 0 \\leq k \\leq \\min(C^2_n, 10^5)$  Phân tích Subtask 1: Quy hoạch động Độ phức tạp: $\\mathcal{O}(nk)$\nTrước khi đến với lời giải chính của bài này. Ta xét một hướng tiếp cận quy hoạch động khi $n$ và $k$ nhỏ. Gọi $\\text{dp}[i][j]$ là số lượng hoán vị của dãy ${1, 2, \\dots, i}$ có $j$ nghịch thế, ta dễ có công thức sau: $$ \\text{dp}[i][j] = \\sum_{x = 0}^{i-1} \\text{dp}[i-1][j-x] $$\n Giải thích công thức Ở một trạng thái $(i, j)$ của hàm quy hoạch động, ta có thể đặt phần tử $i$ vào một trong $i$ vị trí của hoán vị ${1, 2, \\dots, i-1}$ đã dựng trước đó. Số nghịch thế thay đổi như sau:\n Đặt vào vị trí cuối dãy, số nghịch thế không thay đổi. Đặt vào trước phần tử cuối, số nghịch thế tăng lên $1$ do phần tử $i$ lớn hơn các phần tử đã điền và có 1 phần tử đứng sau $i$. \u0026hellip; Đặt vào vị trí đầu dãy, số nghịch thế tăng lên $i-1$ do có $i-1$ phần tử nhỏ hơn $i$ và đứng sau $i$.  Tóm lại, khi đặt phần tử $i$ vào một vị trí trong hoán vị đã dựng, số nghịch thế tăng lên sẽ bằng số phần tử đứng sau $i$, do $i$ lớn hơn tất cả phần tử đã điền.\n Đáp án của bài toán sẽ là $\\text{dp}[n][k]$. Ta sẽ được thuật toán có độ phức tạp là $\\mathcal{O}(nk^2)$, từ đó ta có thể dùng mảng cộng dồn để cải tiến thành $\\mathcal{O}(nk)$.\nSubtask 2: Bao hàm loại trừ Độ phức tạp: $\\mathcal{O}(k\\sqrt{k})$\nNhận xét Trong công thức quy hoạch động trên, ta nhận thấy khi thêm phần tử thứ $i$ vào hoán vị, số cặp nghịch thế lại tăng thêm. Ta gọi lượng tăng thêm đó là $x_i$. Khi đó, bài toán trở thành đếm số dãy số $(x_1, x_2, \\dots, x_n)$ phân biệt thỏa mãn: $$ x_1 + x_2 + \\dots + x_n = k \\text { và } 0 \\leq x_i \\leq i-1 $$\nXét phiên bản đơn giản hơn của bài toán: tìm số lượng nghiệm nhưng không có cận trên của $x_i$. Ta dễ dàng dùng công thức Chia kẹo Euler và tìm được đáp án của bài toán là $C_{n-1+k}^{n-1}$. Như vậy, ta cần phải tìm cách loại bỏ điều kiện $x_i \\leq i-1$ để có thể dùng công thức trên.\nLời giải Gọi $f(j)$ là số nghiệm của bài toán sao cho có ít nhất $j$ phần tử $x_i \\geq i$ (phần tử xấu). Giả sử, ta xác định được $j$ phần tử xấu $x_{i_1} \\geq i_1, x_{i_2} \\geq i_2, \\dots, x_{i_j} \\geq i_j$ và $s = i_1 + i_2 + \\dots + i_j$. Khi đó, ta gọi dãy $y$ sao cho $y_i = x_i - i$ nếu $x_i$ là phần tử xấu, ngược lại ta cho $y_i = x_i$. Như vậy bài toán trở thành đếm số dãy $y$ thỏa mãn: $$ y_1 + y_2 + \\dots + y_n = k - s \\text { và } y_i \\geq 0 $$ Áp dụng Chia kẹo Euler, số lượng dãy thỏa mãn trong trường hợp này là $C^{n-1}_{n-1+(k-s)}$\nNhư vậy ta có cách tính $f(j)$ như sau: Gọi $g(s, j)$ là số cách chọn $j$ số nguyên phân biệt thuộc $[1, n]$ sao cho tổng của chúng là $s$. Khi đó: $$f(j) = \\sum_{s = 0}^{k} g(s, j)\\times C^{n-1}_{n-1+k-s}$$\nTa nhận thấy do $j$ số nguyên phân biệt nên $j \\leq \\sqrt{k}$, vì vậy ta có thể tính $g(s, j)$ bằng quy hoạch động trong $O(k\\sqrt{k})$ theo công thức: $$ g(s, j) = g(s-j, j) + g(s-j, j-1) - g(s-(n+1), j-1) $$\n Giải thích công thức Tại trạng thái $(s, j)$ - $j$ phần tử có tổng là $s$, ta có hai trường hợp chuyển trạng thái:\n $g(s-j, j)$: Tăng tất cả phần tử, mỗi phần tử thêm $1$ đơn vị. $g(s-j, j-1) - g(s-(n+1), j-1)$: Tăng tất cả phần tử trước đó, mỗi phần tử thêm $1$ đơn vị, và tạo thêm một phần tử mới có giá trị là $1$. Sau đó, ta phải loại đi các trường hợp dãy có phần tử lớn hơn $n$.   Cuối cùng, áp dụng nguyên lí bao hàm loại trừ, ta có công thức cho đáp án như sau: $$ \\text{answer} = \\sum_{j = 0}^{\\sqrt{k}} (-1)^j f(j) $$\nCode tham khảo  Hãy xem code khi thực sự cần thiết 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133  // Created by BJMinhNhut #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define mp make_pair #define pb push_back #define fi first #define se second #define FOR(i, a, b) for(int i = (a), _b = (b); i \u0026lt;= _b; ++i) #define FORD(i, a, b) for(int i = (a), _b = (b); i \u0026gt;= _b; --i) #define ALL(a) (a).begin(), (a).end() #define RALL(a) (a).rbegin(), (a).rend() #define MASK(i) (1ll\u0026lt;\u0026lt;(i)) #define BIT(t, i) (((t)\u0026gt;\u0026gt;(i))\u0026amp;1) typedef long long ll; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;ll\u0026gt; vll; typedef pair\u0026lt;ll, ll\u0026gt; pll; typedef pair\u0026lt;int, int\u0026gt; ii; /***Common Functions***/ template \u0026lt;class T\u0026gt; bool minimize(T \u0026amp;a, T b) { if (a \u0026gt; b) { a = b; return true; } return false; } template \u0026lt;class T\u0026gt; bool maximize(T \u0026amp;a, T b) { if (a \u0026lt; b) { a = b; return true; } return false; } template\u0026lt;class T\u0026gt; void read(T \u0026amp;a) { a = 0; char c; while (!isdigit(c = getchar())) {} do { a = a*10 + (c-\u0026#39;0\u0026#39;); } while (isdigit(c = getchar())); } template\u0026lt;class T\u0026gt; void write(T a){ if (a \u0026gt; 9) write(a/10); putchar(a%10 + \u0026#39;0\u0026#39;); } /***End of Template***/ int n, k; const int N = 1e5+5, SQRT = 500, MOD = 1e9+7; int fact[2*N], inv[2*N]; int dp[N][SQRT]; void Input() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; } int modPow(int a, int b) { int res = 1; while (b) { if (b\u0026amp;1) res = 1ll*res*a % MOD; a = 1ll*a*a%MOD; b \u0026gt;\u0026gt;= 1; } return res; } void add(int \u0026amp;a, int b) { a += b; if (a \u0026gt;= MOD) a-= MOD; } void sub(int \u0026amp;a, int b) { a -= b; if (a \u0026lt; 0) a += MOD; } ll minSum(int n) { return 1ll*n*(n+1)/2; } void prepare() { fact[0] = 1; FOR(i, 1, 2*N-1) fact[i] = 1ll*fact[i-1]*i % MOD; inv[2*N-1] = modPow(fact[2*N-1], MOD-2); FORD(i, 2*N-2, 0) inv[i] = 1ll*inv[i+1]*(i+1) % MOD; memset(dp, 0, sizeof dp); dp[0][0] = 1; int sqrt_k = sqrt(k); FOR(s, 1, k) for(int i = 1; minSum(i) \u0026lt;= s; ++i) { if (s-i \u0026gt;= 0) dp[s][i] = (dp[s-i][i] + dp[s-i][i-1]) % MOD; if (s-(n+1) \u0026gt;= 0) sub(dp[s][i], dp[s-(n+1)][i-1]); } } int nCr(int n, int r) { if (n \u0026lt; r) return 0; return 1ll*fact[n]*inv[r] % MOD * inv[n-r] % MOD; } int calc(int j) { int ans = 0; FOR(s, minSum(j), k) { add(ans, 1ll*nCr(n-1+k-s, n-1)*dp[s][j] % MOD); } return ans; } void Solve() { prepare(); int ans = 0; for(int j = 0; minSum(j) \u0026lt;= k; ++j) { if (j\u0026amp;1) sub(ans, calc(j)); else add(ans, calc(j)); } cout \u0026lt;\u0026lt; ans; }\tint main() { ios::sync_with_stdio(0); cin.tie(0); if (fopen(\u0026#34;inputf.in\u0026#34;, \u0026#34;r\u0026#34;)) freopen(\u0026#34;inputf.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); Input(), Solve(); return 0; }    ","date":"2023-01-18T00:00:00Z","permalink":"https://bjminhnhut.github.io/p/k-inversion-permutation/","title":"Hoán vị K-nghịch thế"},{"content":"Có lẽ bên trong mình vẫn là một đứa trẻ, mình cảm thấy điều đó khi được về nhà, được ăn đồ ăn mẹ nấu, và được ngắm nhìn lửa trại chuyên Long An lần hai. Mình cảm thấy may mắn vì covid đã không lấy đi lửa trại của K19. Vào khoảnh khắc ngọn lửa bùng lên vào đêm qua, mình đã cảm thấy một cậu bé ngây thơ, đầy mộng mơ trở lại bên trong con người mình. Có những thứ đã đổi thay so với 3 năm về trước, và có những thứ đã trở nên bất tử trong miền ký ức nhỏ bé này. Ngọn lửa đêm từng thắp sáng ước mơ trong tôi, lại một lần nữa soi sáng niềm hi vọng cho tôi trên chặng hành trình mới.\nacsfid, 13.01.23\n","date":"2023-01-16T00:16:17+07:00","image":"https://bjminhnhut.github.io/p/l%E1%BB%ADa-tr%E1%BA%A1i-chuy%C3%AAn-long-an/cover_hu432d15702ce2155ecfbf34e014553a88_3190825_120x120_fill_box_smart1_3.png","permalink":"https://bjminhnhut.github.io/p/l%E1%BB%ADa-tr%E1%BA%A1i-chuy%C3%AAn-long-an/","title":"Lửa trại chuyên Long An"},{"content":"Nguồn tham khảo  Codeforces - Parallel Binary Search [tutorial] Robert1003 - A Simple Introduction to Parallel Binary Search  Cần biết trước Tìm kiếm nhị phân (tất nhiên vì bạn cần phải hiểu cách tìm kiếm nhị phân hoạt động).\nMở đầu Trong một số bài toán. Ta cần sử dụng kĩ thuật tìm kiếm nhị phân cho rất nhiều truy vấn. Trong đó có một số thao tác trong lúc chặt nhị phân được lặp lại nhiều lần. Để tối ưu hóa việc này, ta thực hiện chặt nhị phân song song - tức chặt nhị phân cùng một lúc nhiều truy vấn.\nBài toán Ta xét bài toán sau đây: Meteors.\nĐề bài Bài toán có thể được phát biểu đơn giản như sau:\nCho $N$ người và $M$ cái túi. Túi thứ $i$ được sở hữu bởi người thứ $o_i$, và mỗi người cần ít nhất $g_i$ quả táo trong các túi mà mình sở hữu. Các cái túi được xếp theo thứ tự thành vòng tròn.\nSau đó, có $K$ sự kiện lần lượt xảy ra, mỗi sự kiện có dạng $l_i, r_i, x_i$: các túi được đánh số từ $l_i$ đến $r_i$ được tăng thêm $x_i$ quả táo ($l_i$ có thể lớn hơn $r_i$ do các túi được xếp thành vòng tròn).\nVới mỗi người, cho biết sau ít nhất bao nhiêu sự kiện thì người đó đạt đủ số lượng quả táo mà mình muốn.\nGiới hạn  $1 \\leq N, M, K \\leq 3 \\cdot 10^5$ $1 \\leq o_i, l_i, r_i \\leq N$ $1 \\leq g_i, x_i \\leq 10^9$  Phân tích Cách tiếp cận dễ nhận ra đó là với mỗi người, ta tiến hành tìm kiếm nhị phân số lượng sự kiện, sau đó cập nhật từng sự kiện lên cây phân đoạn hoặc cây Fenwick. Tuy nhiên, tổng độ phức tạp thời gian cho cách này sẽ lên tới $\\mathcal{O}(N \\cdot \\log K \\cdot K \\cdot \\log M)$ và tất nhiên sẽ bị TLE.\nTừ đây ta nhận ra việc tìm kiếm nhị phân lần lượt cho $N$ là không khả thi. Vậy nên ta sẽ tìm cách áp dụng kĩ thuật chặt nhị phân song song.\nLời giải Từ phân tích trên, ta nhận thấy việc cập nhật các sự kiện từ đầu đến một vị trí nào đó trong các lần chặt nhị phân đã bị lặp lại nhiều lần. Ví dụ như, trong lượt chặt nhị phân đầu tiên của mỗi người, ta đều cần cập nhật lại các sự kiện từ $1$ đến $\\frac{K+1}{2}$.\nTừ đây ta sẽ tiếp cận việc tìm kiếm nhị phân theo một hướng khác: thay vì chặt nhị phân $N$ lần cho từng người, thì ta chỉ chặt nhị phân $1$ lần sao cho trong mỗi lượt, ta tiến hành \u0026ldquo;chia nhóm\u0026rdquo; $N$ người theo kết quả.\nCụ thể, trong lượt đầu tiên, mọi người đều chung một nhóm $[1, K]$. Sang lượt thứ hai, sẽ có một số người nằm ở nhóm $[1, \\frac{K}{2}]$ và số còn lại ở nhóm $(\\frac{K}{2}, K]$ tùy theo điều kiện thỏa mãn hay không. Đến lượt thứ ba, ta có $4$ nhóm: $[1, \\frac{K}{4}]$, $(\\frac{K}{4}, \\frac{2K}{4}]$, $(\\frac{2K}{4}, \\frac{3K}{4}]$, và $(\\frac{3K}{4}, K]$. Như vậy, sau khoảng $\\mathcal{O}(\\log K)$ lượt, mọi người đều được chia vào một điểm, điểm này sẽ chính là đáp án cho người đó. Đồng thời, ở mỗi lượt, ta chỉ cần thực hiện cập nhật lần lượt $K$ sự kiện là có thể tính được cho $N$ người và chia nhóm cho $N$ người đó.\nĐộ phức tạp: Do mỗi thao tác cập nhật $K$ sự kiện mất $\\mathcal{O}(\\log M)$, nên độ phức tạp của thuật toán này là $\\mathcal{O}(\\log Q \\cdot Q \\cdot \\log M)$, vừa đủ với giới hạn đề bài.\nCài đặt Ta cần chuẩn bị:\n Một cấu trúc dữ liệu cho phép cập nhật đoạn và truy vấn một phần tử (có thể dùng cây Fenwick hoặc cây phân đoạn) Một mảng check_list với check_list[x] lưu danh sách những người đang chặt nhị phân tại vị trí $\\text{mid} = x$ Các mảng $L[i], R[i], \\text{best}[i]$ dùng để lưu trạng thái chặt nhị phân của người thứ $i$.  Mỗi lượt trong $\\log K$ lượt chặt nhị phân, ta thực hiện như sau:\n Khởi tạo lại cây Fenwick/phân đoạn. Khởi tạo lại mảng check_list Xác định vị trí chặt nhị phân $\\text{mid}[i] = \\frac{L[i]+ R[i]}{2}$ cho từng người và thêm vào check_list[mid[i]] Duyệt lần lượt các sự kiện và cập nhật lên cây Fenwick/phân đoạn. Khi duyệt đến vị trí $x$ thì duyệt từng người trong check_list[x], tính tổng và cập nhật $L[i], R[i], \\text{best}[i]$ cho người đó. Như vậy trong mỗi lượt ta cập nhật cho cây Fenwick đúng $K$ lần, và gọi truy vấn phần tử trên cây cho đúng $M$ cái túi.    Code AC của mình  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151  // Created by BJMinhNhut #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define mp make_pair #define pb push_back #define fi first #define se second #define FOR(i, a, b) for(int i = (a), _b = (b); i \u0026lt;= _b; ++i) #define FORD(i, a, b) for(int i = (a), _b = (b); i \u0026gt;= _b; --i) #define ALL(a) (a).begin(), (a).end() #define RALL(a) (a).rbegin(), (a).rend() #define MASK(i) (1ll\u0026lt;\u0026lt;(i)) #define BIT(t, i) (((t)\u0026gt;\u0026gt;(i))\u0026amp;1) typedef long long ll; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;ll\u0026gt; vll; typedef pair\u0026lt;ll, ll\u0026gt; pll; typedef pair\u0026lt;int, int\u0026gt; ii; /***Common Functions***/ template \u0026lt;class T\u0026gt; bool minimize(T \u0026amp;a, T b) { if (a \u0026gt; b) { a = b; return true; } return false; } template \u0026lt;class T\u0026gt; bool maximize(T \u0026amp;a, T b) { if (a \u0026lt; b) { a = b; return true; } return false; } /***End of Template***/ int n, m; const int N = 3e5+5; int owner[N];\tint goal[N]; int k; struct Query { int l, r, val; } queries[N]; struct BinarySearch { int l, r, best; BinarySearch(int _l = 0, int _r = 0): l(_l), r(_r), best(_r+1) {} int getMid() {return (l+r) \u0026gt;\u0026gt; 1;} bool finished() {return l \u0026gt; r;} void update(bool go_left) { if (go_left) { best = getMid(); r = getMid() - 1; } else l = getMid() + 1; } } state[N]; struct Fenwick { ll nodes[N]; void reset() { memset(nodes, 0, sizeof nodes); } void update(int k, int val) { for(; k \u0026lt; N; k += k\u0026amp;-k) nodes[k] += val; } void rangeUpdate(int l, int r, int val) { update(l, val); update(r+1, -val); } ll getSum(int k) { ll ans = 0; for(; k \u0026gt; 0; k -= k\u0026amp;-k) ans += nodes[k]; return ans; } } FT; vi check_list[N]; vi sectors[N]; void Input() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; FOR(i, 1, m) cin \u0026gt;\u0026gt; owner[i], sectors[owner[i]].pb(i); FOR(i, 1, n) cin \u0026gt;\u0026gt; goal[i]; cin \u0026gt;\u0026gt; k; FOR(i, 1, k) { cin \u0026gt;\u0026gt; queries[i].l \u0026gt;\u0026gt; queries[i].r \u0026gt;\u0026gt; queries[i].val; } } void update(int l, int r, int val) { if (l \u0026lt;= r) FT.rangeUpdate(l, r, val); else { FT.rangeUpdate(l, m, val); FT.rangeUpdate(1, r, val); } } void Solve() { //init \tFOR(i, 1, n) state[i] = BinarySearch(1, k); // binary search in the range [1, k]  bool changed = true; while (changed) { changed = false; // check whether any state[i] changed  //init \tFT.reset(); FOR(i, 1, n) if (!state[i].finished()) check_list[state[i].getMid()].pb(i); FOR(mid, 1, k) { //sweep through k queries \tupdate(queries[mid].l, queries[mid].r, queries[mid].val); while (check_list[mid].size()) { //check every person who currently has mid = i in binary search \tchanged = true; int cur = check_list[mid].back(); check_list[mid].pop_back(); ll sum = 0; for(int x : sectors[cur]) { sum += FT.getSum(x); if (sum \u0026gt;= goal[cur]) break; } state[cur].update(sum \u0026gt;= goal[cur]); // go left when meet the goal \t} } } FOR(i, 1, n) if (state[i].best \u0026lt;= k) cout \u0026lt;\u0026lt; state[i].best \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //print binary search result \telse cout \u0026lt;\u0026lt; \u0026#34;NIE\\n\u0026#34;; } int main() { ios::sync_with_stdio(0); cin.tie(0); if (fopen(\u0026#34;inputf.in\u0026#34;, \u0026#34;r\u0026#34;)) { freopen(\u0026#34;inputf.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;outputf.in\u0026#34;, \u0026#34;w\u0026#34;, stdout); } Input(), Solve(); return 0; }    Tổng kết  \u0026ldquo;A cool way to visualize this is to think of a binary search tree. Suppose we are doing standard binary search, and we reject the right interval — this can be thought of as moving left in the tree. Similarly, if we reject the left interval, we are moving right in the tree.\nSo what Parallel Binary Search does is move one step down in N binary search trees simultaneously in one \u0026ldquo;sweep\u0026rdquo;, taking $\\mathcal{O}(NX)$ time, where X is dependent on the problem and the data structures used in it. Since the height of each tree is $\\log N$, the complexity is $\\mathcal{O}(NX\\log{N})$.\u0026rdquo; — animeshf\n Mình xin phép dịch lại như sau: Một cách đơn giản, chặt nhị phân song song tức là ta vẽ ra một cây tìm kiếm nhị phân. Cứ mỗi lượt ta duyệt một tầng, và đẩy các phần tử trong mỗi nút thuộc tầng này sang hai nút trái hoặc phải ở tầng dưới. Việc này được thực hiện chỉ trong $\\mathcal{O}(NX)$ với $X$ tùy thuộc vào từng bài toán và cấu trúc dữ liệu mà ta sử dụng. Từ đó dẫn đến tổng độ phức tạp thuật toán là $\\mathcal{O}(NX\\log{N})$.\nNgoài ra, cách xử lí truy vấn ở bài toán trên chỉ là một trường hợp cụ thể, trong các trường hợp khác, về tổng quát, ta cần tư duy rằng ở mỗi tầng, ta có danh sách các truy vấn mới được tạo ra từ việc tìm $\\text{mid}[i]$ và ta cần đi giải quyết nhanh các truy vấn này.\nMột số bài tập khác  ICPC 2022 miền Trung - D: Median Codeforces - 786C: Till I Collapse SPOJ - Meteors HackerEarth - Make n00b_land Great Again! Topcoder - SRM 675 Div1 500  ","date":"2022-11-10T22:30:50+07:00","permalink":"https://bjminhnhut.github.io/p/parallel-binary-search/","title":"Chặt nhị phân song song"}]